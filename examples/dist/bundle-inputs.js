// Generated by purs bundle 0.13.8
var PS = {};
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Semigroupoid"] = $PS["Control.Semigroupoid"] || {};
  var exports = $PS["Control.Semigroupoid"];
  var Semigroupoid = function (compose) {
      this.compose = compose;
  };
  var semigroupoidFn = new Semigroupoid(function (f) {
      return function (g) {
          return function (x) {
              return f(g(x));
          };
      };
  });
  var compose = function (dict) {
      return dict.compose;
  };
  exports["compose"] = compose;
  exports["semigroupoidFn"] = semigroupoidFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Category"] = $PS["Control.Category"] || {};
  var exports = $PS["Control.Category"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];                
  var Category = function (Semigroupoid0, identity) {
      this.Semigroupoid0 = Semigroupoid0;
      this.identity = identity;
  };
  var identity = function (dict) {
      return dict.identity;
  };
  var categoryFn = new Category(function () {
      return Control_Semigroupoid.semigroupoidFn;
  }, function (x) {
      return x;
  });
  exports["identity"] = identity;
  exports["categoryFn"] = categoryFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Function"] = $PS["Data.Function"] || {};
  var exports = $PS["Data.Function"];
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return f(a)(b);
          };
      };
  };
  var $$const = function (a) {
      return function (v) {
          return a;
      };
  };
  exports["flip"] = flip;
  exports["const"] = $$const;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Functor"] = $PS["Data.Functor"] || {};
  var exports = $PS["Data.Functor"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];
  var Functor = function (map) {
      this.map = map;
  };
  var map = function (dict) {
      return dict.map;
  };
  var functorFn = new Functor(Control_Semigroupoid.compose(Control_Semigroupoid.semigroupoidFn));
  exports["Functor"] = Functor;
  exports["map"] = map;
  exports["functorFn"] = functorFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Apply"] = $PS["Control.Apply"] || {};
  var exports = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];                
  var Apply = function (Functor0, apply) {
      this.Functor0 = Functor0;
      this.apply = apply;
  };                      
  var apply = function (dict) {
      return dict.apply;
  };
  var applySecond = function (dictApply) {
      return function (a) {
          return function (b) {
              return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(Data_Function["const"](Control_Category.identity(Control_Category.categoryFn)))(a))(b);
          };
      };
  };
  exports["Apply"] = Apply;
  exports["apply"] = apply;
  exports["applySecond"] = applySecond;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Applicative"] = $PS["Control.Applicative"] || {};
  var exports = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];        
  var Applicative = function (Apply0, pure) {
      this.Apply0 = Apply0;
      this.pure = pure;
  };
  var pure = function (dict) {
      return dict.pure;
  };
  var liftA1 = function (dictApplicative) {
      return function (f) {
          return function (a) {
              return Control_Apply.apply(dictApplicative.Apply0())(pure(dictApplicative)(f))(a);
          };
      };
  };
  exports["Applicative"] = Applicative;
  exports["pure"] = pure;
  exports["liftA1"] = liftA1;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Bind"] = $PS["Control.Bind"] || {};
  var exports = $PS["Control.Bind"];
  var Bind = function (Apply0, bind) {
      this.Apply0 = Apply0;
      this.bind = bind;
  };                     
  var bind = function (dict) {
      return dict.bind;
  };
  exports["Bind"] = Bind;
  exports["bind"] = bind;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Monad"] = $PS["Control.Monad"] || {};
  var exports = $PS["Control.Monad"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];                
  var Monad = function (Applicative0, Bind1) {
      this.Applicative0 = Applicative0;
      this.Bind1 = Bind1;
  };
  var ap = function (dictMonad) {
      return function (f) {
          return function (a) {
              return Control_Bind.bind(dictMonad.Bind1())(f)(function (f$prime) {
                  return Control_Bind.bind(dictMonad.Bind1())(a)(function (a$prime) {
                      return Control_Applicative.pure(dictMonad.Applicative0())(f$prime(a$prime));
                  });
              });
          };
      };
  };
  exports["Monad"] = Monad;
  exports["ap"] = ap;
})(PS);
(function(exports) {
  "use strict";

  exports.fromStringAsImpl = function (just) {
    return function (nothing) {
      return function (radix) {
        var digits;
        if (radix < 11) {
          digits = "[0-" + (radix - 1).toString() + "]";
        } else if (radix === 11) {
          digits = "[0-9a]";
        } else {
          digits = "[0-9a-" + String.fromCharCode(86 + radix) + "]";
        }
        var pattern = new RegExp("^[\\+\\-]?" + digits + "+$", "i");

        return function (s) {
          /* jshint bitwise: false */
          if (pattern.test(s)) {
            var i = parseInt(s, radix);
            return (i | 0) === i ? just(i) : nothing;
          } else {
            return nothing;
          }
        };
      };
    };
  };
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Maybe"] = $PS["Data.Maybe"] || {};
  var exports = $PS["Data.Maybe"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Category = $PS["Control.Category"];
  var Data_Functor = $PS["Data.Functor"];          
  var Nothing = (function () {
      function Nothing() {

      };
      Nothing.value = new Nothing();
      return Nothing;
  })();
  var Just = (function () {
      function Just(value0) {
          this.value0 = value0;
      };
      Just.create = function (value0) {
          return new Just(value0);
      };
      return Just;
  })();
  var maybe = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Nothing) {
                  return v;
              };
              if (v2 instanceof Just) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Maybe (line 217, column 1 - line 217, column 51): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };                                                      
  var functorMaybe = new Data_Functor.Functor(function (v) {
      return function (v1) {
          if (v1 instanceof Just) {
              return new Just(v(v1.value0));
          };
          return Nothing.value;
      };
  });
  var fromMaybe = function (a) {
      return maybe(a)(Control_Category.identity(Control_Category.categoryFn));
  };
  var applyMaybe = new Control_Apply.Apply(function () {
      return functorMaybe;
  }, function (v) {
      return function (v1) {
          if (v instanceof Just) {
              return Data_Functor.map(functorMaybe)(v.value0)(v1);
          };
          if (v instanceof Nothing) {
              return Nothing.value;
          };
          throw new Error("Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var bindMaybe = new Control_Bind.Bind(function () {
      return applyMaybe;
  }, function (v) {
      return function (v1) {
          if (v instanceof Just) {
              return v1(v.value0);
          };
          if (v instanceof Nothing) {
              return Nothing.value;
          };
          throw new Error("Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var applicativeMaybe = new Control_Applicative.Applicative(function () {
      return applyMaybe;
  }, Just.create);
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["fromMaybe"] = fromMaybe;
  exports["applicativeMaybe"] = applicativeMaybe;
  exports["bindMaybe"] = bindMaybe;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Int"] = $PS["Data.Int"] || {};
  var exports = $PS["Data.Int"];
  var $foreign = $PS["Data.Int"];
  var Data_Maybe = $PS["Data.Maybe"];
  var fromStringAs = $foreign.fromStringAsImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var fromString = fromStringAs(10);
  exports["fromString"] = fromString;
})(PS);
(function(exports) {
  "use strict";          

  exports.nullable = function (a, r, f) {
    return a == null ? r : f(a);
  };
})(PS["Data.Nullable"] = PS["Data.Nullable"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Nullable"] = $PS["Data.Nullable"] || {};
  var exports = $PS["Data.Nullable"];
  var $foreign = $PS["Data.Nullable"];
  var Data_Maybe = $PS["Data.Maybe"];                                   
  var toMaybe = function (n) {
      return $foreign.nullable(n, Data_Maybe.Nothing.value, Data_Maybe.Just.create);
  };
  exports["toMaybe"] = toMaybe;
})(PS);
(function(exports) {
  "use strict";

  exports.concatArray = function (xs) {
    return function (ys) {
      if (xs.length === 0) return ys;
      if (ys.length === 0) return xs;
      return xs.concat(ys);
    };
  };
})(PS["Data.Semigroup"] = PS["Data.Semigroup"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Semigroup"] = $PS["Data.Semigroup"] || {};
  var exports = $PS["Data.Semigroup"];
  var $foreign = $PS["Data.Semigroup"];
  var Semigroup = function (append) {
      this.append = append;
  }; 
  var semigroupArray = new Semigroup($foreign.concatArray);
  var append = function (dict) {
      return dict.append;
  };
  exports["append"] = append;
  exports["semigroupArray"] = semigroupArray;
})(PS);
(function(exports) {
  "use strict";

  exports.showIntImpl = function (n) {
    return n.toString();
  };
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Show"] = $PS["Data.Show"] || {};
  var exports = $PS["Data.Show"];
  var $foreign = $PS["Data.Show"];
  var Show = function (show) {
      this.show = show;
  };                                                 
  var showInt = new Show($foreign.showIntImpl);
  var show = function (dict) {
      return dict.show;
  };
  exports["show"] = show;
  exports["showInt"] = showInt;
})(PS);
(function(exports) {
  "use strict";

  exports.unit = {};
})(PS["Data.Unit"] = PS["Data.Unit"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Unit"] = $PS["Data.Unit"] || {};
  var exports = $PS["Data.Unit"];
  var $foreign = $PS["Data.Unit"];
  exports["unit"] = $foreign.unit;
})(PS);
(function(exports) {
  "use strict";

  exports.pureE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };
})(PS["Effect"] = PS["Effect"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Effect"] = $PS["Effect"] || {};
  var exports = $PS["Effect"];
  var $foreign = $PS["Effect"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad = $PS["Control.Monad"];
  var Data_Functor = $PS["Data.Functor"];                    
  var monadEffect = new Control_Monad.Monad(function () {
      return applicativeEffect;
  }, function () {
      return bindEffect;
  });
  var bindEffect = new Control_Bind.Bind(function () {
      return applyEffect;
  }, $foreign.bindE);
  var applyEffect = new Control_Apply.Apply(function () {
      return functorEffect;
  }, Control_Monad.ap(monadEffect));
  var applicativeEffect = new Control_Applicative.Applicative(function () {
      return applyEffect;
  }, $foreign.pureE);
  var functorEffect = new Data_Functor.Functor(Control_Applicative.liftA1(applicativeEffect));
  exports["functorEffect"] = functorEffect;
  exports["applyEffect"] = applyEffect;
  exports["applicativeEffect"] = applicativeEffect;
  exports["bindEffect"] = bindEffect;
})(PS);
(function(exports) {
  const LAZY_NODE = 2
  const TEXT_NODE = 3

  const compose = (f, g) => f && g ? x => f(g(x)) : f || g; 

  const h = name => ps => children => {
      const style = {};
      const props = {style};
      const vdom = { name, children: children.filter(x => x), props, node: null };
      const n = ps.length;
      for (let i = 0; i < n; i++) {
          const [t, k, v] = ps[i];
          if (t === 0)
              vdom.key = k;
          else if (t == 1)
              props[k] = v;
          else if (t === 2)
              props.class = (props.class ? props.class + " " : "") + k;
          else if (t === 3)
              style[k] = v;
      }
      return vdom;
  }

  const createTextVNode = text => ({
      name: text,
      props: {},
      children: [],
      type: 3
  })                           
  exports.attr = k => v => [1, k, v]
  exports.unsafeOnWithEffect = k => v => [1, k, v]
  exports.h = h
  exports.text = createTextVNode
})(PS["Pha"] = PS["Pha"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Pha"] = $PS["Pha"] || {};
  var exports = $PS["Pha"];
  var $foreign = $PS["Pha"];
  exports["h"] = $foreign.h;
  exports["text"] = $foreign.text;
  exports["attr"] = $foreign.attr;
  exports["unsafeOnWithEffect"] = $foreign.unsafeOnWithEffect;
})(PS);
(function(exports) {
  // code comes from hyperapp by Jorge Bucaran
  // https://github.com/jorgebucaran/hyperapp
  // modified by Guillaume Bagan

  const RECYCLED_NODE = 1
  const LAZY_NODE = 2
  const TEXT_NODE = 3
  const EMPTY_OBJ = {}
  const EMPTY_ARR = []
  const map = EMPTY_ARR.map
  const defer = requestAnimationFrame || setTimeout

  const merge = (a, b) => Object.assign({}, a, b);
  const compose = (f, g) => f && g ? x => f(g(x)) : f || g;

  const patchProperty = (node, key, oldValue, newValue, listener, isSvg, mapf) => {
      if (key === "key") {
      }
      else if (key === "style") {
          for (let k in merge(oldValue, newValue)) {
              oldValue = newValue == null || newValue[k] == null ? "" : newValue[k]
              if (k[0] === "-") {
                  node[key].setProperty(k, oldValue)
              } else {
                  node[key][k] = oldValue
              }
          }
      } else if (typeof newValue === "function") {
          if (
              !((node.actions || (node.actions = {}))[key] = mapf ? mapf(newValue) : newValue)
          ) {
              node.removeEventListener(key, listener)
          } else if (!oldValue) {
              node.addEventListener(key, listener)
          }
      } else if (!isSvg && key !== "list" && key in node) {
          node[key] = newValue
      } else if (newValue == null || newValue === false || (key === "class" && !newValue)) {
          node.removeAttribute(key)
      } else {
          node.setAttribute(key, newValue)
      }
  }

  const createNode = (vnode, listener, isSvg, mapf) => {
      const node =
          vnode.type === TEXT_NODE
              ? document.createTextNode(vnode.name)
              : (isSvg = isSvg || vnode.name === "svg")
                  ? document.createElementNS("http://www.w3.org/2000/svg", vnode.name)
                  : document.createElement(vnode.name)
      const props = vnode.props
      mapf = compose(mapf, vnode.mapf);

      for (let k in props) {
          patchProperty(node, k, null, props[k], listener, isSvg, mapf)
      }

      for (let i = 0, len = vnode.children.length; i < len; i++) {
          node.appendChild(
              createNode(
                  (vnode.children[i] = getVNode(vnode.children[i])),
                  listener,
                  isSvg,
                  mapf
              )
          )
      }

      return (vnode.node = node)
  }

  const getKey = vnode => vnode == null ? null : vnode.key;

  const patch = function (parent, node, oldVNode, newVNode, listener, isSvg, mapf) {
      if (oldVNode === newVNode) {
      } else if (
          oldVNode != null &&
          oldVNode.type === TEXT_NODE &&
          newVNode.type === TEXT_NODE
      ) {
          if (oldVNode.name !== newVNode.name)
              node.nodeValue = newVNode.name
      } else if (oldVNode == null || oldVNode.name !== newVNode.name) {
          node = parent.insertBefore(
              createNode((newVNode = getVNode(newVNode)), listener, isSvg, mapf),
              node
          )
          if (oldVNode != null) {
              parent.removeChild(oldVNode.node)
          }
      } else {
          let tmpVKid
          let oldVKid

          let oldKey
          let newKey

          const oldVProps = oldVNode.props
          const newVProps = newVNode.props

          const oldVKids = oldVNode.children
          const newVKids = newVNode.children

          let oldHead = 0
          let newHead = 0
          let oldTail = oldVKids.length - 1
          let newTail = newVKids.length - 1

          mapf = compose(mapf, newVNode.mapf);
          isSvg = isSvg || newVNode.name === "svg"

          for (let i in merge(oldVProps, newVProps)) {
              if (
                  (i === "value" || i === "selected" || i === "checked"
                      ? node[i]
                      : oldVProps[i]) !== newVProps[i]
              ) {
                  patchProperty(node, i, oldVProps[i], newVProps[i], listener, isSvg, mapf)
              }
          }

          while (newHead <= newTail && oldHead <= oldTail) {
              if (
                  (oldKey = getKey(oldVKids[oldHead])) == null ||
                  oldKey !== getKey(newVKids[newHead])
              ) {
                  break
              }

              patch(
                  node,
                  oldVKids[oldHead].node,
                  oldVKids[oldHead],
                  (newVKids[newHead] = getVNode(
                      newVKids[newHead++],
                      oldVKids[oldHead++]
                  )),
                  listener,
                  isSvg,
                  mapf
              )
          }

          while (newHead <= newTail && oldHead <= oldTail) {
              if (
                  (oldKey = getKey(oldVKids[oldTail])) == null ||
                  oldKey !== getKey(newVKids[newTail])
              ) {
                  break
              }

              patch(
                  node,
                  oldVKids[oldTail].node,
                  oldVKids[oldTail],
                  (newVKids[newTail] = getVNode(
                      newVKids[newTail--],
                      oldVKids[oldTail--]
                  )),
                  listener,
                  isSvg,
                  mapf
              )
          }

          if (oldHead > oldTail) {
              while (newHead <= newTail) {
                  node.insertBefore(
                      createNode(
                          (newVKids[newHead] = getVNode(newVKids[newHead++])),
                          listener,
                          isSvg,
                          mapf
                      ),
                      (oldVKid = oldVKids[oldHead]) && oldVKid.node
                  )
              }
          } else if (newHead > newTail) {
              while (oldHead <= oldTail) {
                  node.removeChild(oldVKids[oldHead++].node)
              }
          } else {
              for (var i = oldHead, keyed = {}, newKeyed = {}; i <= oldTail; i++) {
                  if ((oldKey = oldVKids[i].key) != null) {
                      keyed[oldKey] = oldVKids[i]
                  }
              }

              while (newHead <= newTail) {
                  oldKey = getKey((oldVKid = oldVKids[oldHead]))
                  newKey = getKey(
                      (newVKids[newHead] = getVNode(newVKids[newHead], oldVKid))
                  )

                  if (
                      newKeyed[oldKey] ||
                      (newKey != null && newKey === getKey(oldVKids[oldHead + 1]))
                  ) {
                      if (oldKey == null) {
                          node.removeChild(oldVKid.node)
                      }
                      oldHead++
                      continue
                  }

                  if (newKey == null) {
                      if (oldKey == null) {
                          patch(
                              node,
                              oldVKid && oldVKid.node,
                              oldVKid,
                              newVKids[newHead],
                              listener,
                              isSvg,
                              mapf
                          )
                          newHead++
                      }
                      oldHead++
                  } else {
                      if (oldKey === newKey) {
                          patch(
                              node,
                              oldVKid.node,
                              oldVKid,
                              newVKids[newHead],
                              listener,
                              isSvg,
                              mapf
                          )
                          newKeyed[newKey] = true
                          oldHead++
                      } else {
                          if ((tmpVKid = keyed[newKey]) != null) {
                              patch(
                                  node,
                                  node.insertBefore(tmpVKid.node, oldVKid && oldVKid.node),
                                  tmpVKid,
                                  newVKids[newHead],
                                  listener,
                                  isSvg,
                                  mapf
                              )
                              newKeyed[newKey] = true
                          } else {
                              patch(
                                  node,
                                  oldVKid && oldVKid.node,
                                  null,
                                  newVKids[newHead],
                                  listener,
                                  isSvg,
                                  mapf
                              )
                          }
                      }
                      newHead++
                  }
              }

              while (oldHead <= oldTail) {
                  if (getKey((oldVKid = oldVKids[oldHead++])) == null) {
                      node.removeChild(oldVKid.node)
                  }
              }

              for (let i in keyed) {
                  if (newKeyed[i] == null) {
                      node.removeChild(keyed[i].node)
                  }
              }
          }
      }

      return (newVNode.node = node)
  }

  const propsChanged = function (a, b) {
      for (let k in a) if (a[k] !== b[k]) return true
      for (let k in b) if (a[k] !== b[k]) return true
  }

  const getVNode = (newVNode, oldVNode) =>
      typeof newVNode.type === "function"
          ? ((!oldVNode || oldVNode.memo == null || propsChanged(oldVNode.memo, newVNode.memo)) &&
              ((oldVNode = newVNode.type(newVNode.memo)).memo = newVNode.memo),
              oldVNode)
          : newVNode

  const createVNode = (name, props, children, node, key, type) =>
      ({ name, props, children, node, type, key })

  const recycleNode = node =>
      node.nodeType === TEXT_NODE
          ? createTextVNode(node.nodeValue, node)
          : createVNode(
              node.nodeName.toLowerCase(),
              EMPTY_OBJ,
              map.call(node.childNodes, recycleNode),
              node,
              null,
              RECYCLED_NODE
          )

  const shouldRestart = (a, b) => {
      if (a !== b) {
          for (let k in merge(a, b)) {
              if (a[k] !== b[k] && !isSameAction(a[k], b[k]))
                  return true
              b[k] = a[k]
          }
      }
  }

  const patchSubs = (oldSubs, newSubs, dispatch) => {
      for (var
              i = 0, oldSub, newSub, subs = [];
          i < oldSubs.length || i < newSubs.length;
          i++
      ) {
          oldSub = oldSubs[i]
          newSub = newSubs[i]
          subs.push(
              newSub
                  ? !oldSub || newSub.fn !== oldSub.fn || shouldRestart(newSub[0], oldSub[1])
                      ? [
                          newSub[0],
                          newSub[1],
                          newSub[0](dispatch)(newSub[1])(),
                          oldSub && oldSub[2]()
                      ]
                      : oldSub
                  : oldSub && oldSub[2]()
          )
      }
      return subs
  }

  const app = props => {
      let state = {}
      let lock = false
      let subs = []

      const listener = function (event) {
          dispatchEvent(event)(this.actions[event.type])()
      }

      const getState = () => state

      const setState = newState => () => {
          if (state !== newState) {
              state = newState
              subs = patchSubs(subs, subscriptions(state), dispatch)
              if (!lock) {
                  lock = true
                  defer(() => render(state)());
              }
          }
          return state
      }

      let node = null;
      let vdom = null;

      const renderVDom = newVdom => () => {
          lock = false
          node = patch(
              node.parentNode,
              node,
              vdom,
              vdom = newVdom,
              listener
          )
      }

      const { render, subscriptions, dispatch, dispatchEvent, init } = props({ getS: getState, setS: setState, renderVDom })

      return rootnode => () => {
          node = document.getElementById(rootnode)
          if (!node)
              return
          vdom = node && recycleNode(node)
          init()
      }
  }

  exports.app = app
})(PS["Pha.App.Internal"] = PS["Pha.App.Internal"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Pha.App.Internal"] = $PS["Pha.App.Internal"] || {};
  var exports = $PS["Pha.App.Internal"];
  var $foreign = $PS["Pha.App.Internal"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Unit = $PS["Data.Unit"];                
  var getDispatchers = function (getS) {
      return function (setS) {
          return function (update) {
              var modify = function (fn) {
                  return function __do() {
                      var $2 = getS();
                      return setS(fn($2))();
                  };
              };
              var dispatch = update(modify);
              var dispatchEvent = function (ev) {
                  return function (handler) {
                      return function __do() {
                          var msg = handler(ev)();
                          if (msg instanceof Data_Maybe.Nothing) {
                              return Data_Unit.unit;
                          };
                          if (msg instanceof Data_Maybe.Just) {
                              return dispatch(msg.value0)();
                          };
                          throw new Error("Failed pattern match at Pha.App.Internal (line 37, column 13 - line 39, column 36): " + [ msg.constructor.name ]);
                      };
                  };
              };
              return {
                  modify: modify,
                  dispatch: dispatch,
                  dispatchEvent: dispatchEvent
              };
          };
      };
  };
  exports["getDispatchers"] = getDispatchers;
  exports["app"] = $foreign.app;
})(PS);
(function(exports) {
  /* global window */
  "use strict";

  exports.window = function () {
    return window;
  };
})(PS["Web.HTML"] = PS["Web.HTML"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Web.HTML"] = $PS["Web.HTML"] || {};
  var exports = $PS["Web.HTML"];
  var $foreign = $PS["Web.HTML"];
  exports["window"] = $foreign.window;
})(PS);
(function(exports) {
  "use strict";

  exports.setTitle = function (title) {
    return function (doc) {
      return function () {
        doc.title = title;
        return {};
      };
    };
  };
})(PS["Web.HTML.HTMLDocument"] = PS["Web.HTML.HTMLDocument"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Web.HTML.HTMLDocument"] = $PS["Web.HTML.HTMLDocument"] || {};
  var exports = $PS["Web.HTML.HTMLDocument"];
  var $foreign = $PS["Web.HTML.HTMLDocument"];
  exports["setTitle"] = $foreign.setTitle;
})(PS);
(function(exports) {
  "use strict";

  exports.document = function (window) {
    return function () {
      return window.document;
    };
  };
})(PS["Web.HTML.Window"] = PS["Web.HTML.Window"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Web.HTML.Window"] = $PS["Web.HTML.Window"] || {};
  var exports = $PS["Web.HTML.Window"];
  var $foreign = $PS["Web.HTML.Window"];
  exports["document"] = $foreign.document;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Pha.App"] = $PS["Pha.App"] || {};
  var exports = $PS["Pha.App"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Function = $PS["Data.Function"];
  var Data_Unit = $PS["Data.Unit"];
  var Effect = $PS["Effect"];
  var Pha_App_Internal = $PS["Pha.App.Internal"];
  var Web_HTML = $PS["Web.HTML"];
  var Web_HTML_HTMLDocument = $PS["Web.HTML.HTMLDocument"];
  var Web_HTML_Window = $PS["Web.HTML.Window"];                
  var attachTo = Data_Function.flip(Pha_App_Internal.app);
  var app = function (v) {
      return function (v1) {
          var v2 = Pha_App_Internal.getDispatchers(v1.getS)(v1.setS)(v.update);
          var render = function (state) {
              var v3 = v.view(state);
              return function __do() {
                  Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Web_HTML.window)(Web_HTML_Window.document))(Web_HTML_HTMLDocument.setTitle(v3.title))();
                  return v1.renderVDom(v3.body)();
              };
          };
          var init2 = Control_Apply.applySecond(Effect.applyEffect)(v1.setS(v.init.state))(v.init.effect(v2.modify));
          return {
              render: render,
              init: init2,
              subscriptions: v.subscriptions,
              dispatch: v2.dispatch,
              dispatchEvent: v2.dispatchEvent
          };
      };
  };
  var sandbox = function (v) {
      return app({
          init: {
              state: v.init,
              effect: function (v1) {
                  return Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit);
              }
          },
          view: function (st) {
              return {
                  title: "Pha App",
                  body: v.view(st)
              };
          },
          update: function (v1) {
              return function ($27) {
                  return v1(v.update($27));
              };
          },
          subscriptions: Data_Function["const"]([  ])
      });
  };
  exports["sandbox"] = sandbox;
  exports["attachTo"] = attachTo;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Pha.Attributes"] = $PS["Pha.Attributes"] || {};
  var exports = $PS["Pha.Attributes"];
  var Pha = $PS["Pha"];
  var value = Pha.attr("value");
  var checked = function (b) {
      return Pha.attr("checked")((function () {
          if (b) {
              return "true";
          };
          return "";
      })());
  };
  exports["checked"] = checked;
  exports["value"] = value;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Pha.Elements"] = $PS["Pha.Elements"] || {};
  var exports = $PS["Pha.Elements"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Pha = $PS["Pha"];
  var input = function (t) {
      return function (props) {
          return Pha.h("input")(Data_Semigroup.append(Data_Semigroup.semigroupArray)([ Pha.attr("type")(t) ])(props))([  ]);
      };
  };                           
  var div = Pha.h("div");      
  var br = Pha.h("br")([  ])([  ]);
  exports["br"] = br;
  exports["div"] = div;
  exports["input"] = input;
})(PS);
(function(exports) {
  "use strict";

  exports._currentTarget = function (e) {
    return e.currentTarget;
  };
})(PS["Web.Event.Event"] = PS["Web.Event.Event"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Web.Event.Event"] = $PS["Web.Event.Event"] || {};
  var exports = $PS["Web.Event.Event"];
  var $foreign = $PS["Web.Event.Event"];
  var Data_Nullable = $PS["Data.Nullable"];
  var currentTarget = function ($8) {
      return Data_Nullable.toMaybe($foreign["_currentTarget"]($8));
  };
  exports["currentTarget"] = currentTarget;
})(PS);
(function(exports) {
  "use strict";

  // ----------------------------------------------------------------------------

  exports.checked = function (input) {
    return function () {
      return input.checked;
    };
  };

  // ----------------------------------------------------------------------------

  exports.value = function (input) {
    return function () {
      return input.value;
    };
  };
})(PS["Web.HTML.HTMLInputElement"] = PS["Web.HTML.HTMLInputElement"] || {});
(function(exports) {
  "use strict";

  exports._unsafeReadProtoTagged = function (nothing, just, name, value) {
    if (typeof window !== "undefined") {
      var ty = window[name];
      if (ty != null && value instanceof ty) {
        return just(value);
      }
      return nothing;
    } 
    var obj = value;
    while (obj != null) {
      var proto = Object.getPrototypeOf(obj);
      var constructorName = proto.constructor.name;
      if (constructorName === name) {
        return just(value);
      } else if (constructorName === "Object") {
        return nothing;
      }
      obj = proto;
    }
    return nothing;
  };
})(PS["Web.Internal.FFI"] = PS["Web.Internal.FFI"] || {});
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Web.Internal.FFI"] = $PS["Web.Internal.FFI"] || {};
  var exports = $PS["Web.Internal.FFI"];
  var $foreign = $PS["Web.Internal.FFI"];
  var Data_Maybe = $PS["Data.Maybe"];                
  var unsafeReadProtoTagged = function (name) {
      return function (value) {
          return $foreign["_unsafeReadProtoTagged"](Data_Maybe.Nothing.value, Data_Maybe.Just.create, name, value);
      };
  };
  exports["unsafeReadProtoTagged"] = unsafeReadProtoTagged;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Web.HTML.HTMLInputElement"] = $PS["Web.HTML.HTMLInputElement"] || {};
  var exports = $PS["Web.HTML.HTMLInputElement"];
  var $foreign = $PS["Web.HTML.HTMLInputElement"];
  var Web_Internal_FFI = $PS["Web.Internal.FFI"];                                  
  var fromEventTarget = Web_Internal_FFI.unsafeReadProtoTagged("HTMLInputElement");
  exports["fromEventTarget"] = fromEventTarget;
  exports["checked"] = $foreign.checked;
  exports["value"] = $foreign.value;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Pha.Events"] = $PS["Pha.Events"] || {};
  var exports = $PS["Pha.Events"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Effect = $PS["Effect"];
  var Pha = $PS["Pha"];
  var Web_Event_Event = $PS["Web.Event.Event"];
  var Web_HTML_HTMLInputElement = $PS["Web.HTML.HTMLInputElement"];
  var on = Pha.unsafeOnWithEffect;
  var onchecked = function (f) {
      var fn = function (ev) {
          var v = Control_Bind.bind(Data_Maybe.bindMaybe)(Web_Event_Event.currentTarget(ev))(Web_HTML_HTMLInputElement.fromEventTarget);
          if (v instanceof Data_Maybe.Nothing) {
              return Control_Applicative.pure(Effect.applicativeEffect)(Data_Maybe.Nothing.value);
          };
          if (v instanceof Data_Maybe.Just) {
              return Data_Functor.map(Effect.functorEffect)(Data_Functor.map(Data_Functor.functorFn)(Data_Maybe.Just.create)(f))(Web_HTML_HTMLInputElement.checked(v.value0));
          };
          throw new Error("Failed pattern match at Pha.Events (line 128, column 9 - line 130, column 66): " + [ v.constructor.name ]);
      };
      return on("change")(fn);
  };
  var onvaluechange = function (f) {
      var fn = function (ev) {
          var v = Control_Bind.bind(Data_Maybe.bindMaybe)(Web_Event_Event.currentTarget(ev))(Web_HTML_HTMLInputElement.fromEventTarget);
          if (v instanceof Data_Maybe.Nothing) {
              return Control_Applicative.pure(Effect.applicativeEffect)(Data_Maybe.Nothing.value);
          };
          if (v instanceof Data_Maybe.Just) {
              return Data_Functor.map(Effect.functorEffect)(Data_Functor.map(Data_Functor.functorFn)(Data_Maybe.Just.create)(f))(Web_HTML_HTMLInputElement.value(v.value0));
          };
          throw new Error("Failed pattern match at Pha.Events (line 120, column 9 - line 122, column 64): " + [ v.constructor.name ]);
      };
      return on("change")(fn);
  };
  exports["onvaluechange"] = onvaluechange;
  exports["onchecked"] = onchecked;
})(PS);
(function($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Example.Inputs"] = $PS["Example.Inputs"] || {};
  var exports = $PS["Example.Inputs"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Int = $PS["Data.Int"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Show = $PS["Data.Show"];
  var Pha = $PS["Pha"];
  var Pha_App = $PS["Pha.App"];
  var Pha_Attributes = $PS["Pha.Attributes"];
  var Pha_Elements = $PS["Pha.Elements"];
  var Pha_Events = $PS["Pha.Events"];                
  var ChangeVal1 = (function () {
      function ChangeVal1(value0) {
          this.value0 = value0;
      };
      ChangeVal1.create = function (value0) {
          return new ChangeVal1(value0);
      };
      return ChangeVal1;
  })();
  var ChangeVal2 = (function () {
      function ChangeVal2(value0) {
          this.value0 = value0;
      };
      ChangeVal2.create = function (value0) {
          return new ChangeVal2(value0);
      };
      return ChangeVal2;
  })();
  var ChangeOp = (function () {
      function ChangeOp(value0) {
          this.value0 = value0;
      };
      ChangeOp.create = function (value0) {
          return new ChangeOp(value0);
      };
      return ChangeOp;
  })();
  var update = function (v) {
      if (v instanceof ChangeVal1) {
          return function (v1) {
              return {
                  val1: v.value0,
                  val2: v1.val2,
                  isMul: v1.isMul
              };
          };
      };
      if (v instanceof ChangeVal2) {
          return function (v1) {
              return {
                  val1: v1.val1,
                  val2: v.value0,
                  isMul: v1.isMul
              };
          };
      };
      if (v instanceof ChangeOp) {
          return function (v1) {
              return {
                  val1: v1.val1,
                  val2: v1.val2,
                  isMul: v.value0
              };
          };
      };
      throw new Error("Failed pattern match at Example.Inputs (line 34, column 1 - line 34, column 29): " + [ v.constructor.name ]);
  };
  var result = function (v) {
      return Data_Maybe.fromMaybe("invalid input")(Control_Bind.bind(Data_Maybe.bindMaybe)(Data_Int.fromString(v.val1))(function (x) {
          return Control_Bind.bind(Data_Maybe.bindMaybe)(Data_Int.fromString(v.val2))(function (y) {
              return Control_Applicative.pure(Data_Maybe.applicativeMaybe)(Data_Show.show(Data_Show.showInt)((function () {
                  if (v.isMul) {
                      return x * y | 0;
                  };
                  return x + y | 0;
              })()));
          });
      }));
  };
  var view = function (v) {
      return Pha_Elements.div([  ])([ Pha_Elements.input("text")([ Pha.attr("size")("5"), Pha_Events.onvaluechange(ChangeVal1.create), Pha_Attributes.value(v.val1) ]), Pha.text((function () {
          if (v.isMul) {
              return " * ";
          };
          return " + ";
      })()), Pha_Elements.input("text")([ Pha.attr("size")("5"), Pha_Events.onvaluechange(ChangeVal2.create), Pha_Attributes.value(v.val2) ]), Pha.text(" = " + result(v)), Pha_Elements.br, Pha_Elements.input("checkbox")([ Pha_Attributes.checked(v.isMul), Pha_Events.onchecked(ChangeOp.create) ]), Pha.text("Multiplication instead of addition") ]);
  };
  var init = {
      val1: "2",
      val2: "4",
      isMul: false
  };
  var main = Pha_App.attachTo("root")(Pha_App.sandbox({
      init: init,
      view: view,
      update: update
  }));
  exports["ChangeVal1"] = ChangeVal1;
  exports["ChangeVal2"] = ChangeVal2;
  exports["ChangeOp"] = ChangeOp;
  exports["init"] = init;
  exports["result"] = result;
  exports["update"] = update;
  exports["view"] = view;
  exports["main"] = main;
})(PS);
PS["Example.Inputs"].main();